* Reflecting Syntax
  * Base Expressions vs. Uninterpreted Functions
    - What do we do if we see "f a b c" and we have never seen "f" before?
      - We need to extend the context with "f".
      - If we want to keep track of the variables that occur inside the
        expression, then we need to abstract "f" with respect to each of the
	variables this means that Uninterpreted Functions are simply a
	representation choice for uninterpreted bases.
  * The real problem seems to be about extending the context.
    - I have a reflected term indexed by a denotation function "d".
    - At this point, my world is closed wrt "d". 
    - If I see something that I haven't seen before, I can't reference it in
      a way that supports decidable equality.
  * "Known Symbols" seem to be important because they give us a way to do 
    computation
    - for example, even reflecting something simple like 1 + 1 = 2 won't be
      possible unless we have this as a specific rewrite. 
    - To address this, we can specialize a small number of domains (probably 
      bit-vectors) that have nice computable properties and use them to reflect
      and do some unification.

* TODOs
  * Separation logic
    * Reflect separation logic formula
    * Prove separation logic lemmas
    * Factor out separation logic core
    * Solved case of cancelProver
    * Move provers to their own file
  * Expressions
    * Unification variables
    * Prover that uses lemmas

* Dependent vs. Non-dependent representation
  * Semi-dependent styles 
    * how much benefit does this give us?
    * what is the computational cost?
    - break the type record apart
    - break the signature and ssignature records apart
