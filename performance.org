* Reification
  - restructure reification to recur over the term exactly once
    - collect the types (as a list)
    - functions and predicates as tuples
    - build the environments at the end
  * we can do this if we reify a function that takes a list of terms and builds
    the term. the term will be built at the end when it is passed the list of 
    constants, e.g. to reflect
       x + 4
    we build the following
       uvars:  tt
       vars:   (x,tt)
       funcs:  (+,tt)
       consts: (4,tt)
       term:   (fun ts (ls : list (expr ts)) => Func 0 (Var 0 :: nth_default ls 0 DEFAULT_TERM :: nil))
    here, DEFAULT_TERM can be any term, it will never be used. we then reflect the constants and build the environments
    and construct the list of constants. beta reduction on the term applied to the arguments will produce the correct result
    - how much of a win would this actually give us since terms are only indexed on types?      

* Repr
  - could be (list (option T)) * T
    - canonical, no need for compression
    - not sure whether the types would actually work out
      - we could probably make it work the same way
  - Implemented in Env.v


  
