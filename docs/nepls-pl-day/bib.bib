@article{chlipala2011bedrock,
 author = {Chlipala, Adam},
 title = {Mostly-automated verification of low-level programs in computational separation logic},
 journal = {SIGPLAN Notices},
 issue_date = {June 2011},
 volume = {46},
 issue = {6},
 month = {June},
 year = {2011},
 issn = {0362-1340},
 pages = {234--245},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/1993316.1993526},
 doi = {http://doi.acm.org/10.1145/1993316.1993526},
 acmid = {1993526},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {functional programming, interactive proof assistants, low-level programming languages, separation logic},
 abstract = {Several recent projects have shown the feasibility of verifying low-level systems software. Verifications based on automated theorem-proving have omitted reasoning about first-class code pointers, which is critical for tasks like certifying implementations of threads and processes. Conversely, verifications that deal with first-class code pointers have featured long, complex, manual proofs. In this paper, we introduce the Bedrock framework, which supports mostly-automated proofs about programs with the full range of features needed to implement, e.g., language runtime systems.

The heart of our approach is in mostly-automated discharge of verification conditions inspired by separation logic. Our take on separation logic is computational, in the sense that function specifications are usually written in terms of reference implementations in a purely functional language. Logical quantifiers are the most challenging feature for most automated verifiers; by relying on functional programs (written in the expressive language of the Coq proof assistant), we are able to avoid quantifiers almost entirely. This leads to some dramatic improvements compared to both past work in classical verification, which we compare against with implementations of data structures like binary search trees and hash tables; and past work in verified programming with code pointers, which we compare against with examples like function memoization and a cooperative threading library.}
}

@incollection {ni2007xcap,
   author = {Ni, Zhaozhong and Yu, Dachuan and Shao, Zhong},
   affiliation = {Microsoft Research, One Microsoft Way, Redmond, WA 98052 U.S.A.},
   title = {Using XCAP to Certify Realistic Systems Code: Machine Context Management},
   booktitle = {Theorem Proving in Higher Order Logics},
   series = {Lecture Notes in Computer Science},
   editor = {Schneider, Klaus and Brandt, Jens},
   publisher = {Springer Berlin / Heidelberg},
   isbn = {978-3-540-74590-7},
   keyword = {Computer Science},
   pages = {189-206},
   volume = {4732},
   url = {http://dx.doi.org/10.1007/978-3-540-74591-4\_15},
   note = {10.1007/978-3-540-74591-4\_15},
   abstract = {Formal, modular, and mechanized verification of realistic systems code is desirable but challenging. Verification of machine context management (a basis of multi-tasking) is one representative example. With context operations occurring hundreds to thousands of times per second on every computer, their correctness deserves careful examination. Given the small and stable code bases, it is a common misunderstanding that the context management code is suitable for informal scrutiny and testing. Unfortunately, after being extensively studied and used for decades, it still proves to be a common source of bugs and confusion. Yet its verification remains difficult due to the machine-level detail, irregular patterns of control flows, and rich application scenarios. This paper reports our experience applying XCAP—a recent theoretical verification framework—to certify a realistic x86 implementation of machine context management. XCAP supports expressive and modular logical specifications, but has only previously been applied on simple idealized machine and code. By applying the XCAP theory to an x86 machine model, building libraries of common proof tactics and lemmas, composing specifications for the context data structures and routines, and proving that the code behave accordingly, we achieved the first formal, modular, and mechanized verification of realistic x86 context management code. Our proofs are fully mechanized in the Coq proof assistant. Our certified library code runs on stock hardware and can be linked with other certified systems and application code. Our technique applies to other variants or extensions of context management ( e.g. , more complex context, different platforms), provides a solid basis for further verification of thread implementation and concurrent programs, and illustrates how to achieve formal, modular, and mechanized verification of realistic systems code.},
   year = {2007}
}