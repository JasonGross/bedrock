* TODOs
*** Gregory
    - Single uvars environment
    - Expression unification
    - Array plugin
    - hash proofs
    - symbolic evaluation proofs
    - clean up TypedPackage tactics
*** Other
    - tactic performance

* Reification
*** Two-stage Approach
    - current implementation
    - collectTypes_Xxx ltac to collect a list of types
    - reify_Xxx to build the term indexed by the type list
*** Single Pass Approach
  - restructure reification to recur over the term exactly once
    - collect the types (as a list)
    - functions and predicates as tuples
    - build the environments at the end
  * we can do this if we reify a function that takes a list of terms and builds
    the term. the term will be built at the end when it is passed the list of 
    constants, e.g. to reflect
       x + 4
    we build the following
       uvars:  tt
       vars:   (x,tt)
       funcs:  (+,tt)
       consts: (4,tt)
       term:   (fun ts (ls : list (expr ts)) => Func 0 (Var 0 :: nth_default ls 0 DEFAULT_TERM :: nil))
    here, DEFAULT_TERM can be any term, it will never be used. we then reflect the constants and build the environments
    and construct the list of constants. beta reduction on the term applied to the arguments will produce the correct result
    - how much of a win would this actually give us since terms are only indexed on types?      
  - CONS:
    - the type of the pair is quadratic in the term!
      - an alternative would be to build a list of dyn, 
	i.e. list {| T : Type ; V : T |}.
*** Plugin-based reification
    - Like to avoid this if possible, but it might be necessary to make
      things really fast.

* Expr & SepExpr
*** Variables & environments
    - there are two environments
      - meta_env carries meta variables, i.e. Coq ? variables
        - the numbers are treated as global identifiers
      - vars_env carries quantified variables
        - the numbers are debrujin *indices*
	- this makes some operations awkward, but it is make reifying terms
	  in Ltac easy.
	- NOTE: regardless of whether we use levels or indicies it is important
	  that the reified vars environment is *always* nil
          - reification uses 0 argument functions to represent variables 
	    that are not quantified in the goal, i.e. they are already in
	    the context
    - NOTE: it seems like it might be more useful to do debrujin *levels*

* Repr (environments for types, functions and predicates)
*** Use [list (option T) * T] 
    (implemented [[src:Env.v]] rev. 330)
    - Benefits
      - canonical, no need for compression

#+LINK: src:../src/%s
#+LINK: example:../examples/%s
#+STARTUP: showall
