* TODOs
*** Gregory
    - expression unification proofs
    - Array plugin
    - hash proofs
    - symbolic evaluation proofs
    - clean up TypedPackage tactics
    - factor out IL

* Reification
*** Two-stage Approach
    - current implementation
    - collectTypes_Xxx ltac to collect a list of types
    - reify_Xxx to build the term indexed by the type list
*** Single Pass Approach
  - restructure reification to recur over the term exactly once
    - collect the types (as a list)
    - functions and predicates as tuples
    - build the environments at the end
  * we can do this if we reify a function that takes a list of terms and builds
    the term. the term will be built at the end when it is passed the list of 
    constants, e.g. to reflect
       x + 4
    we build the following
       uvars:  tt
       vars:   (x,tt)
       funcs:  (+,tt)
       consts: (4,tt)
       term:   (fun ts (ls : list (expr ts)) => Func 0 (Var 0 :: nth_default ls 0 DEFAULT_TERM :: nil))
    here, DEFAULT_TERM can be any term, it will never be used. we then reflect the constants and build the environments
    and construct the list of constants. beta reduction on the term applied to the arguments will produce the correct result
    - how much of a win would this actually give us since terms are only indexed on types?      
  - CONS:
    - the type of the pair is quadratic in the term!
      - an alternative would be to build a list of dyn, 
	i.e. list {| T : Type ; V : T |}.
*** Plugin-based reification
    - Like to avoid this if possible, but it might be necessary to make
      things really fast.

* Unfolding
*** Forward Unfolding
    (Note that we are looking for matches between two structures, 
     it is equivalent to iterate the predicates first, rather than the lemmas)
    - For each lemma
      1) hash the LHS of the lemma and find the head function name [f]
	 (alternatively, we could demand that the LHS is an exact application
	  of the [Func] constructor, in which case hashing is essentially a
	  no-op)
      2) look for [f] in the heap
         - if not found, continue
	 - if found,
	   3) iterate the applications to find one that unifies
	   4) solve the pure premises of the lemma using the prover
	   5) hash the RHS of the lemma
	   6) prepend the existentials of the RHS to Vars
	   7) add the pure facts to pures list
	   8) remove the matched application from the heap
	   9) star the heap with the hashed RHS
*** Backward Unfolding
    - For each lemma
      1) hash the RHS of the lemma and find the head function name [f]
	 (alternatively, we could demand that the RHS is an exact application
	  of the [Func] constructor, in which case hashing is essentially a
	  no-op)
      2) look for [f] in the heap
         - if not found, continue
	 - if found,
	   3) iterate the applications to find one that unifies
	   4) solve the pure premises of the lemma using the prover
	   5) hash the LHS of the lemma
	   6) prepend the existentials of the LHS to UVars
	   7) add the pure facts to pures list
	   8) remove the matched application from the heap
	   9) star the heap with the hashed LHS

* Expr & SepExpr
*** Variables & environments
    - there are two environments
      - meta_env carries meta variables, i.e. Coq ? variables
        - the numbers are treated as global identifiers
      - vars_env carries quantified variables
        - the numbers are debrujin *indices*
	- this makes some operations awkward, but it is make reifying terms
	  in Ltac easy.
	- NOTE: regardless of whether we use levels or indicies it is important
	  that the reified vars environment is *always* nil
          - reification uses 0 argument functions to represent variables 
	    that are not quantified in the goal, i.e. they are already in
	    the context
    - NOTE: it seems like it might be more useful to do debrujin *levels*
      - these act exactly like global variables in the SHeap representation
    - reification is not modular in extending the vars environment
      so whenever we reify it is essentially that vars is nil!

* Repr (environments for types, functions and predicates)
*** Use [list (option T) * T] 
    (implemented [[src:Env.v]] rev. 330)
    - Benefits
      - canonical, no need for compression

#+LINK: src:../src/%s
#+LINK: example:../examples/%s
#+STARTUP: showall
