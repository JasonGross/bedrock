* TODOs
*** Gregory
    - Single uvars environment
    - Expression unification
    - Array plugin
    - hash proofs
    - symbolic evaluation proofs
    - clean up TypedPackage tactics
*** Other
    - tactic performance

* Reification
*** Two-stage Approach
    - current implementation
    - collectTypes_Xxx ltac to collect a list of types
    - reify_Xxx to build the term indexed by the type list
*** Single Pass Approach
  - restructure reification to recur over the term exactly once
    - collect the types (as a list)
    - functions and predicates as tuples
    - build the environments at the end
  * we can do this if we reify a function that takes a list of terms and builds
    the term. the term will be built at the end when it is passed the list of 
    constants, e.g. to reflect
       x + 4
    we build the following
       uvars:  tt
       vars:   (x,tt)
       funcs:  (+,tt)
       consts: (4,tt)
       term:   (fun ts (ls : list (expr ts)) => Func 0 (Var 0 :: nth_default ls 0 DEFAULT_TERM :: nil))
    here, DEFAULT_TERM can be any term, it will never be used. we then reflect the constants and build the environments
    and construct the list of constants. beta reduction on the term applied to the arguments will produce the correct result
    - how much of a win would this actually give us since terms are only indexed on types?      
  - CONS:
    - the type of the pair is quadratic in the term!
      - an alternative would be to build a list of dyn, i.e. list {| T : Type ; V : T |}.
*** Plugin-based reification
    - Like to avoid this if possible, but it might be necessary to make things really fast.

* Repr (environments for types, functions and predicates)
*** Use [list (option T) * T] 
    (implemented [[src:Env.v]] rev. 330)
    - Benefits
      - canonical, no need for compression

#+LINK: src:../src/%s
#+LINK: example:../examples/%s
#+STARTUP: showall
